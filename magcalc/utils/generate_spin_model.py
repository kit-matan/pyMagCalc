#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Generate a spin_model.py file from a CIF file using pyMagCalc's cif_utils.
Features:
- Auto-extracts unit cell and atoms.
- Performs shell analysis to identify unique bond distances.
- Auto-generates spin_interactions with distance-based logic.
- Auto-generates Hamiltonian.
- Supports optional Single-Ion Anisotropy (SIA) and Dzyaloshinskii-Moriya (DM) terms.

Usage:
    python generate_spin_model.py <cif_file> <output_file> [magnetic_elements...] [--cutoff 6.0] [--with-sia] [--with-dm]

Example:
    python generate_spin_model.py KFe3J.cif my_spin_model.py Fe --with-sia
"""
import sys
import os
import argparse
import numpy as np
from itertools import product
from numpy import linalg as la

# Adjust path to import cif_utils from the parent/root directory if needed
current_dir = os.path.dirname(os.path.abspath(__file__))
parent_dir = os.path.dirname(current_dir)
if parent_dir not in sys.path:
    sys.path.insert(0, parent_dir)

try:
    import cif_utils
except ImportError:
    # Try importing assuming this script is run from root
    try:
        import cif_utils
    except ImportError:
        print("Error: Could not import cif_utils. Make sure you are in the pyMagCalc directory or it is in your PYTHONPATH.")
        sys.exit(1)

def analyze_shells(uc_vectors, atoms_uc, cutoff=8.0, tol=0.01):
    """
    Analyze neighbor shells to find unique distances.
    """
    positions = np.array([a['pos'] for a in atoms_uc])
    
    # Create supercell positions for neighbors
    # For robust shell finding up to ~8A, we usually need +/- 1 or 2 cells
    u_range = range(-1, 2)
    v_range = range(-1, 2)
    w_range = range(-1, 2)
    
    unique_distances = set()
    
    for i in range(len(positions)):
        pos_i = positions[i] @ uc_vectors
        
        for u, v, w in product(u_range, v_range, w_range):
            translation = u * uc_vectors[0] + v * uc_vectors[1] + w * uc_vectors[2]
            
            for j in range(len(positions)):
                if u==0 and v==0 and w==0 and i==j:
                    continue # Self
                
                pos_j = positions[j] @ uc_vectors + translation
                
                d = la.norm(pos_i - pos_j)
                if d < tol: continue 
                if d > cutoff: continue
                
                # Round to tolerance to group shells
                d_rounded = round(d, 3) 
                unique_distances.add(d_rounded)
                
    sorted_dists = sorted(list(unique_distances))
    return sorted_dists

def generate_header(filename, cif_source):
    return f'''#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Auto-generated spin_model.py
Source CIF: {cif_source}
Generated by pyMagCalc utility.

Edit this file to define your Hamiltonian parameters and interaction logic.
"""
import sympy as sp
import numpy as np
from numpy import linalg as la
from itertools import product

'''

def generate_unit_cell(uc_vectors):
    return f'''
def unit_cell():
    """Unit cell vectors extracted from CIF"""
    va = np.array({uc_vectors[0].tolist()})
    vb = np.array({uc_vectors[1].tolist()})
    vc = np.array({uc_vectors[2].tolist()})
    uc = [va, vb, vc]
    return np.array(uc)
'''

def generate_atom_pos(atoms_uc):
    lines = []
    lines.append('def atom_pos():')
    lines.append('    """Atomic positions extracted from CIF"""')
    
    pos_list_str = []
    for atom in atoms_uc:
        label = atom['label']
        pos = atom['pos']
        # Format as np.array call
        line = f'    {label} = np.array({pos}) # {label}'
        lines.append(line)
        pos_list_str.append(label)
        
    lines.append(f'    r_pos = [{", ".join(pos_list_str)}]')
    lines.append('    return np.array(r_pos)')
    return "\n".join(lines) + "\n"

def generate_atom_pos_ouc():
    return '''
def atom_pos_ouc():
    """
    Generate atomic positions outside the unit cell (neighbors).
    Default implementation: Nearest neighbors in adjacent unit cells (-1 to 1).
    """
    uc = unit_cell()
    apos = atom_pos()
    apos_len = len(apos)
    
    # Generate 3x3x1 supercell neighbors
    r_pos_ouc = [apos[k] for k in range(apos_len)] # Center cell first
    
    neighbors = [
        apos[k] + i * uc[0] + j * uc[1] + l * uc[2]
        for i, j, l in product(range(-1, 2), repeat=3)
        if (i, j, l) != (0, 0, 0)
        for k in range(apos_len)
    ]
    r_pos_ouc.extend(neighbors)
    
    return np.array(r_pos_ouc)
'''

def generate_rot_mats():
    return '''
def rot_mat(atom_list, p):
    """
    Rotation matrix to transform spins to global coordinates.
    """
    return [sp.eye(3) for _ in atom_list]


def mpr(p):
    """
    Rotation matrix for magnetic structure / chirality.
    """
    apos = atom_pos()
    return [sp.eye(3) for _ in apos]
'''

def generate_spin_interactions(shells, with_dm=False):
    lines = []
    lines.append('def spin_interactions(p):')
    lines.append('    """')
    lines.append('    Generate spin interaction matrices (Jex, DM).')
    lines.append('    Auto-generated logic based on distance shells.')
    
    n_shells = len(shells)
    j_names = [f"J{i+1}" for i in range(n_shells)]
    
    if with_dm:
        dm_names = []
        for i in range(n_shells):
            dm_names.extend([f"Dx{i+1}", f"Dy{i+1}", f"Dz{i+1}"])
        lines.append(f'    Inputs: p = [{", ".join(j_names)}, {", ".join(dm_names)}, ...]')
    else:
        lines.append(f'    Inputs: p = [{", ".join(j_names)}, ...]')
        
    lines.append('    """')
    
    # Unpack J parameters
    lines.append(f'    # Unpack Exchange Parameters')
    lines.append(f'    {", ".join(j_names)} = p[0:{n_shells}]')
    
    # Unpack DM parameters if needed
    if with_dm:
        lines.append(f'    # Unpack DM Parameters (3 per shell)')
        # This can be long, handle splits if needed, but python handles long lines okay.
        lines.append(f'    {", ".join(dm_names)} = p[{n_shells}:{n_shells + 3*n_shells}]')
    
    lines.append('')
    lines.append('    apos = atom_pos()')
    lines.append('    N_atom = len(apos)')
    lines.append('    apos_ouc = atom_pos_ouc()')
    lines.append('    N_atom_ouc = len(apos_ouc)')
    lines.append('    ')
    lines.append('    Jex = sp.zeros(N_atom, N_atom_ouc)')
    lines.append('    DM = sp.zeros(N_atom, N_atom_ouc)')
    lines.append('    ')
    lines.append('    dist_tol = 0.05')
    lines.append('    ')
    lines.append('    for i in range(N_atom):')
    lines.append('        for j in range(N_atom_ouc):')
    lines.append('            d = la.norm(apos[i] - apos_ouc[j])')
    
    # Shell logic
    for i, dist in enumerate(shells):
        cond = 'if' if i == 0 else 'elif'
        lines.append(f'            {cond} abs(d - {dist:.4f}) < dist_tol: # Shell {i+1} : {dist:.4f} A')
        lines.append(f'                Jex[i, j] = J{i+1}')
        if with_dm:
            # DM vector assignment
            # DM elements are expected to be sympy Matrices of shape (3, 1) or (3,)
            lines.append(f'                DM[i, j] = sp.Matrix([Dx{i+1}, Dy{i+1}, Dz{i+1}])')
            
    lines.append('    ')
    lines.append('    return Jex, DM')
    return "\n".join(lines) + "\n"

def generate_hamiltonian(num_shells, with_sia=False, with_dm=False):
    param_count = num_shells
    if with_dm:
        param_count += 3 * num_shells
    if with_sia:
        param_count += 1
        
    lines = []
    lines.append('def Hamiltonian(Sxyz, pr):')
    lines.append('    """')
    lines.append('    Define the symbolic spin Hamiltonian.')
    lines.append('    Auto-generated standard Heisenberg Model.')
    if with_dm: lines.append('    Includes Dzyaloshinskii-Moriya (DM) interactions.')
    if with_sia: lines.append('    Includes Single-Ion Anisotropy (SIA).')
    lines.append('    """')
    lines.append('    Jex, DM = spin_interactions(pr)')
    lines.append('    HM = 0')
    lines.append('    ')
    lines.append('    gamma = 2.0')
    lines.append('    mu_B = 5.788e-2 # meV/T')
    lines.append('    ')
    
    # Unpack extra params for H and SIA
    if with_sia:
        # SIA param is after J's and DM's
        # Index in pr would be num_shells + (3*num_shells if DM) 
        sia_idx = num_shells + (3 * num_shells if with_dm else 0)
        lines.append(f'    D_sia = pr[{sia_idx}] # Single-Ion Anisotropy')
        
    lines.append(f'    # Magnetic field assumed last')
    lines.append(f'    H_mag = pr[-1] if len(pr) > {param_count} else 0')
    
    lines.append('    ')
    lines.append('    apos = atom_pos()')
    lines.append('    N_uc = len(apos)')
    lines.append('    atoms_ouc = atom_pos_ouc()')
    lines.append('    N_ouc = len(atoms_ouc)')
    lines.append('    ')
    lines.append('    for i in range(N_uc):')
    lines.append('        for j in range(N_ouc):')
    lines.append('            if Jex[i, j] != 0:')
    lines.append('                # Heisenberg Term (0.5 factor for double counting correction)')
    lines.append('                HM += 0.5 * Jex[i, j] * (')
    lines.append('                    Sxyz[i][0] * Sxyz[j][0] + ')
    lines.append('                    Sxyz[i][1] * Sxyz[j][1] + ')
    lines.append('                    Sxyz[i][2] * Sxyz[j][2]')
    lines.append('                )')
    
    if with_dm:
        lines.append('                # Dzyaloshinskii-Moriya Term: D_ij . (Si x Sj)')
        lines.append('                # S_cross = Si x Sj')
        lines.append('                Sc_x = Sxyz[i][1]*Sxyz[j][2] - Sxyz[i][2]*Sxyz[j][1]')
        lines.append('                Sc_y = Sxyz[i][2]*Sxyz[j][0] - Sxyz[i][0]*Sxyz[j][2]')
        lines.append('                Sc_z = Sxyz[i][0]*Sxyz[j][1] - Sxyz[i][1]*Sxyz[j][0]')
        lines.append('                ')
        lines.append('                # Dot product with D vector')
        lines.append('                # DM[i,j] is expected to be a sympy Matrix/vector')
        lines.append('                D_vec = DM[i, j]')
        lines.append('                HM += 0.5 * (')
        lines.append('                    D_vec[0] * Sc_x +')
        lines.append('                    D_vec[1] * Sc_y +')
        lines.append('                    D_vec[2] * Sc_z')
        lines.append('                )')

    # SIA Term
    if with_sia:
        lines.append('        # Single-Ion Anisotropy: D_sia * (Sz)^2')
        lines.append('        # Assumed along Z axis for simplicity')
        lines.append('        HM += D_sia * (Sxyz[i][2])**2')
        
    # Zeeman Term
    lines.append('        # Zeeman Term (Field along Z)')
    lines.append('        HM += gamma * mu_B * Sxyz[i][2] * H_mag')
    
    lines.append('    ')
    lines.append('    return HM')
    
    return "\n".join(lines) + "\n"

def main():
    parser = argparse.ArgumentParser(description="Generate spin_model.py from CIF.")
    parser.add_argument("cif_file", help="Path to input CIF file")
    parser.add_argument("output_file", help="Path to output python file")
    parser.add_argument("magnetic_elements", nargs="*", help="List of magnetic elements to filter (e.g. Fe Ni)")
    parser.add_argument("--cutoff", type=float, default=6.0, help="Cutoff distance for shell analysis (Angstrom)")
    parser.add_argument("--with-sia", action="store_true", help="Include Single-Ion Anisotropy term")
    parser.add_argument("--with-dm", action="store_true", help="Include Dzyaloshinskii-Moriya interaction terms")
    
    args = parser.parse_args()
    
    magnetic_elements = args.magnetic_elements if args.magnetic_elements else None
    
    print(f"Loading structure from {args.cif_file}...")
    if magnetic_elements:
        print(f"Filtering for magnetic elements: {magnetic_elements}")
        
    try:
        structure_data = cif_utils.load_cif_structure(args.cif_file, magnetic_elements)
    except Exception as e:
        print(f"Error loading CIF: {e}")
        sys.exit(1)
        
    uc_vectors = np.array(structure_data['unit_cell_vectors'])
    atoms_uc = structure_data['atoms_uc']
    
    print(f"Found {len(atoms_uc)} atoms in unit cell.")
    print(f"Analyzing shells up to {args.cutoff} A...")
    
    shells = analyze_shells(uc_vectors, atoms_uc, cutoff=args.cutoff)
    print(f"Found {len(shells)} unique shells: {shells}")
    
    print(f"Generating {args.output_file}...")
    if args.with_sia: print("Including Single-Ion Anisotropy.")
    if args.with_dm: print("Including DM interactions.")
    
    with open(args.output_file, 'w') as f:
        f.write(generate_header(args.output_file, args.cif_file))
        f.write(generate_unit_cell(uc_vectors))
        f.write(generate_atom_pos(atoms_uc))
        f.write(generate_atom_pos_ouc())
        f.write(generate_rot_mats())
        f.write(generate_spin_interactions(shells, with_dm=args.with_dm))
        f.write(generate_hamiltonian(len(shells), with_sia=args.with_sia, with_dm=args.with_dm))
        
    print("Done.")

if __name__ == "__main__":
    main()
